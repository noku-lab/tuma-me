const { releaseHeldFunds } = require('../../jobs/releaseFunds');
const Transaction = require('../../models/Transaction');
const Ledger = require('../../models/Ledger');
const User = require('../../models/User');
const mongoose = require('mongoose');

describe('Release Funds Job', () => {
  let retailer, wholesaler;

  beforeAll(async () => {
    if (mongoose.connection.readyState === 0) {
      const mongoUri = process.env.MONGODB_URI || 'mongodb://admin:password123@localhost:27017/tuma-me-test?authSource=admin';
      await mongoose.connect(mongoUri);
    }
  });

  afterAll(async () => {
    // Only close if connection is open
    if (mongoose.connection.readyState !== 0) {
      try {
        await mongoose.connection.close();
      } catch (error) {
        // Ignore errors when closing connection
      }
    }
  });

  beforeEach(async () => {
    // Clean up in correct order to avoid foreign key issues
    await Transaction.deleteMany({});
    await Ledger.deleteMany({});
    await User.deleteMany({});

    // Create test users with unique emails per test run
    const timestamp = Date.now();
    retailer = new User({
      email: `retailer-${timestamp}@test.com`,
      password: 'password123',
      name: 'Test Retailer',
      role: 'retailer',
    });
    await retailer.save();

    wholesaler = new User({
      email: `wholesaler-${timestamp}@test.com`,
      password: 'password123',
      name: 'Test Wholesaler',
      role: 'wholesaler',
    });
    await wholesaler.save();
  });

  test('should skip if MongoDB is not connected', async () => {
    // Mock disconnected state
    const originalReadyState = mongoose.connection.readyState;
    Object.defineProperty(mongoose.connection, 'readyState', {
      get: () => 0,
      configurable: true,
    });

    const result = await releaseHeldFunds();

    expect(result.skipped).toBe(true);
    expect(result.released).toBe(0);

    // Restore original state
    Object.defineProperty(mongoose.connection, 'readyState', {
      get: () => originalReadyState,
      configurable: true,
    });
  });

  test('should release funds for transactions past hold release time', async () => {
    const pastDate = new Date(Date.now() - 13 * 60 * 60 * 1000); // 13 hours ago

    // Create transaction - transactionId will be auto-generated by pre-save hook
    // We need to bypass validation temporarily or set a dummy ID
    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000);
    const transactionId = `TXN-${timestamp}-${random}`;
    
    const transaction = new Transaction({
      transactionId, // Set manually to satisfy required validation
      retailer: retailer._id,
      wholesaler: wholesaler._id,
      amount: 100,
      description: 'Test transaction',
      paymentMethod: 'ecocash',
      status: 'on_hold',
      holdReleaseAt: pastDate,
    });
    await transaction.save();
    
    // Verify transaction and wholesaler are set up correctly
    const savedTransaction = await Transaction.findById(transaction._id).populate('wholesaler');
    expect(savedTransaction.wholesaler).toBeTruthy();
    expect(savedTransaction.wholesaler._id).toBeDefined();

    const result = await releaseHeldFunds();

    expect(result.released).toBe(1);

    // Check transaction status updated
    const updatedTransaction = await Transaction.findById(transaction._id);
    expect(updatedTransaction).toBeTruthy();
    expect(updatedTransaction.status).toBe('completed');
    expect(updatedTransaction.completedAt).toBeDefined();

    // Check ledger entry created
    const ledgerEntries = await Ledger.find({ transactionId: transaction.transactionId });
    expect(ledgerEntries.length).toBeGreaterThan(0);
    const releaseEntry = ledgerEntries.find(e => e.type === 'release');
    expect(releaseEntry).toBeDefined();
    expect(releaseEntry.amount).toBe(100);
  });

  test('should not release funds if hold release time not reached', async () => {
    const futureDate = new Date(Date.now() + 2 * 60 * 60 * 1000); // 2 hours in future

    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000);
    const transactionId = `TXN-${timestamp}-${random}`;
    
    const transaction = new Transaction({
      transactionId,
      retailer: retailer._id,
      wholesaler: wholesaler._id,
      amount: 100,
      description: 'Test transaction',
      paymentMethod: 'ecocash',
      status: 'on_hold',
      holdReleaseAt: futureDate,
    });
    await transaction.save();

    const result = await releaseHeldFunds();

    expect(result.released).toBe(0);

    // Check transaction status not changed
    const updatedTransaction = await Transaction.findById(transaction._id);
    expect(updatedTransaction.status).toBe('on_hold');
  });

  test('should not release funds if dispute is filed', async () => {
    const pastDate = new Date(Date.now() - 13 * 60 * 60 * 1000);

    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000);
    const transactionId = `TXN-${timestamp}-${random}`;
    
    const transaction = new Transaction({
      transactionId,
      retailer: retailer._id,
      wholesaler: wholesaler._id,
      amount: 100,
      description: 'Test transaction',
      paymentMethod: 'ecocash',
      status: 'on_hold',
      holdReleaseAt: pastDate,
      dispute: {
        reason: 'Test dispute',
        filedAt: new Date(),
        filedBy: retailer._id,
      },
    });
    await transaction.save();
    
    // Verify transaction is set up correctly
    const savedTransaction = await Transaction.findById(transaction._id);
    expect(savedTransaction).toBeTruthy();
    expect(savedTransaction.dispute).toBeTruthy();
    expect(savedTransaction.dispute.filedAt).toBeDefined();

    const result = await releaseHeldFunds();

    expect(result.released).toBe(0);

    // Check transaction status not changed
    const updatedTransaction = await Transaction.findById(transaction._id);
    expect(updatedTransaction).toBeTruthy();
    expect(updatedTransaction.status).toBe('on_hold');
  });

  test('should not process transactions that are not on_hold', async () => {
    const pastDate = new Date(Date.now() - 13 * 60 * 60 * 1000);

    const timestamp = Date.now();
    const random = Math.floor(Math.random() * 10000);
    const transactionId = `TXN-${timestamp}-${random}`;
    
    const transaction = new Transaction({
      transactionId,
      retailer: retailer._id,
      wholesaler: wholesaler._id,
      amount: 100,
      description: 'Test transaction',
      paymentMethod: 'ecocash',
      status: 'pending',
      holdReleaseAt: pastDate,
    });
    await transaction.save();

    const result = await releaseHeldFunds();

    expect(result.released).toBe(0);
  });

  test('should handle multiple transactions', async () => {
    const pastDate = new Date(Date.now() - 13 * 60 * 60 * 1000);

    const timestamp1 = Date.now();
    const random1 = Math.floor(Math.random() * 10000);
    const transactionId1 = `TXN-${timestamp1}-${random1}`;
    
    const transaction1 = new Transaction({
      transactionId: transactionId1,
      retailer: retailer._id,
      wholesaler: wholesaler._id,
      amount: 100,
      description: 'Transaction 1',
      paymentMethod: 'ecocash',
      status: 'on_hold',
      holdReleaseAt: pastDate,
    });
    await transaction1.save();
    await transaction1.populate('wholesaler');

    const timestamp2 = Date.now() + 1;
    const random2 = Math.floor(Math.random() * 10000);
    const transactionId2 = `TXN-${timestamp2}-${random2}`;
    
    const transaction2 = new Transaction({
      transactionId: transactionId2,
      retailer: retailer._id,
      wholesaler: wholesaler._id,
      amount: 200,
      description: 'Transaction 2',
      paymentMethod: 'bank_transfer',
      status: 'on_hold',
      holdReleaseAt: pastDate,
    });
    await transaction2.save();
    await transaction2.populate('wholesaler');

    const result = await releaseHeldFunds();

    expect(result.released).toBe(2);

    const updated1 = await Transaction.findById(transaction1._id);
    const updated2 = await Transaction.findById(transaction2._id);
    expect(updated1.status).toBe('completed');
    expect(updated2.status).toBe('completed');
  });
});
